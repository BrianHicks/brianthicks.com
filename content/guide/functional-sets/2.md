---
date: "2016-11-21T09:00:00-06:00"
title: "Functional Sets, Part 2: Rotation"
meta: [Elm 0.18]
showPublished: false
showModified: true
aliases:
 - /post/2016/11/21/functional-sets-part-2-rotation/
menu:
  functional-sets:
    weight: 2
---

Last time we started making a set using a binary search tree.
Let's keep moving!

<!--more-->

## Quick Recap

We're modeling [binary search trees](https://en.wikipedia.org/wiki/Binary_search_tree) like this in Elm:

```elm
type Set comparable
    = Tree comparable (Set comparable) (Set comparable)
    | Empty
```

We can create empty sets using `empty`, sets from a single item using `singleton`, and bigger sets by using `insert` or `fromList`.

## Off Balance

Unfortunately, the `insert` function  we wrote last time has a problem.
It will keep all our values organized, but if you insert values in a certain order you get a very inefficient structure back.

The simplest place this happens is when you try to create a set from a list that's already in order.
When we run `fromList [1, 2, 3, 4, 5]` we'd want to get this:

{{< figure src="/images/sets/one-through-five-balanced.png"
           caption="A balanced tree containing the numbers 1 through 5." >}}

But instead, we get:

{{< figure src="/images/sets/one-through-five-unbalanced.png"
           caption="An unbalanced tree, the result of our naÃ¯ve insert implementation" >}}

Think about how we'd retrieve 5 from these sets.

In the nice balanced tree above:

1. We'd see that the head is 2.
2. Ok, so look in the right subtree, where the head is 4.
3. 5 is greater than 4, so right subtree again, and we've found it.

Three steps, not terrible.
But what about the unbalanced tree?

1. The head is 1, so look in the right.
2. The next head is 2, so look in the right.
3. The *next* head is 3, so look in the right.
4. You get the point. Right again.
5. Finally, we find our 5.

So three steps versus five.
That doesn't make a huge difference, right?

Well, that's true for small sets, but imagine if you had 1,000 items in your set.
You don't want to look through all 1,000!

It turns out that if we have a balanced set, we can look up an item in *worst case* `log2(n)` operations, where `n` is the amount of items in the set.
For a set of 1,000 items, that means about 10 operations instead of 1,000.
This is a *huge* difference!

So, to get the benefits, let's make sure that our data structure stays balanced.

## AVL Trees

Fortunately for us, tons of smart people have thought about this problem.
We have to choose from red-black trees, scapegoat trees, splay trees, treaps&hellip;
But we're going to use [AVL trees](https://en.wikipedia.org/wiki/AVL_tree), which take their name from their inventors: Adelson-Velsky and Landis.

AVL trees balance by making sure the *height* of each subtree is about the same.
In our example from before, the balanced tree had a height of 2, while the unbalanced tree had a height of 5.

{{< figure src="/images/sets/one-through-five-balanced.png"
           caption="A balanced tree of 1 through 5 has a height of 2." >}}

Take note that we're using the number of levels of nodes to define the height, not how many nodes there are (this is called the *weight*.)
This means that:

- An empty set has a height of 0.
- A singleton set has a height of 1.
- Anything else is the height of it's tallest subtree, plus 1.

When we `insert`, we'll look at the new heights of the trees after insertion.
If the difference between them is greater than 1 (so if the left is taller than the right, or the reverse), we'll rotate!

We want to keep track of these heights without recomputing them every time, so we'll change our implementation of `Set` to look like this:

```elm
type Set comparable
    = Tree Int comparable (Set comparable) (Set comparable)
    | Empty
```

The `Int` as the new first field of `Tree` will hold the tree's height.
We'll need to refer to this field often, let's write a quick function to get the height of any tree:

```elm
height : Set comparable -> Int
height set =
    case set of
        Empty ->
            0

        Tree height _ _ _ ->
            height
```

Now we change our constructor functions.
`empty` can stay the same, but singleton will change to add a height:

```elm
singleton : comparable -> Set comparable
singleton item =
    Tree 1 item empty empty
```

&hellip;and we'll need an entirely new constructor, `tree`:

```elm
tree : comparable -> Set comparable -> Set comparable -> Set comparable
tree head left right =
    Tree
        (max (height left) (height right) + 1)
        head
        left
        right
```

We'll use this in `insert` in place of direct calls to `Tree`:

```elm
insert : comparable -> Set comparable -> Set comparable
insert item set =
    case set of
        Empty ->
            singleton item

        Tree _ head left right ->
            if item < head then
                tree head (insert item left) right
            else if item > head then
                tree head left (insert item right)
            else
                set
```

That's all we need to do to set the stage!
Now that we keep track of balance, we can make changes during insertion to *keep* the tree balanced.

## Tree Rotation

Wikipedia has an *amazing* GIF to explain tree rotation:

{{< figure src="/images/sets/Tree_rotation_animation_250x250.gif"
           caption="A Tree Rotating Left and Right"
           attr="Wikipedia"
           attrlink="https://en.wikipedia.org/wiki/File:Tree_rotation_animation_250x250.gif" >}}

In words: to rotate left, we have to have a tree with a non-empty subtree as it's right subtree.
For the sake of clarity, we're going to call the original head `head` and the subtree's head `subHead`.

Remember how all the values to the left of a subtree are less than the head, and the values to the right are greater?
Well, that means that the left subtree of the right subtree contains values *between* the two heads!
We'll use that nifty little property to our advantage here.
Let's refer to the left subtree of the original tree as `lessThans`, and the left and right subtrees of the subtree as `betweens` and `greaterThans`.

Now, armed with our terms, we can rotate left.
We'll be creating a new `Tree`, with `subHead` as the head.
The left subtree will be another new tree, with `head` as the head, `lessThans` as the left subtree, and `betweens` as the right subtree.
Last, we attach `greaterThans` as the right subtree.
To rotate right, we do the opposite.

Whew!
That's a ton of words to describe something that's fairly succinct in code:

```elm
rotateLeft : Set comparable -> Set comparable
rotateLeft set =
    case set of
        Tree _ head lessThans (Tree _ subHead betweens greaterThans) ->
            tree subHead (tree head lessThans betweens) greaterThans

        _ ->
            set


rotateRight : Set comparable -> Set comparable
rotateRight set =
    case set of
        Tree _ head (Tree _ subHead lessThans betweens) greaterThans ->
            tree subHead lessThans (tree head betweens greaterThans)

        _ ->
            set
```

We always put `lessThans`, `betweens` and `greaterThans` in order in the source.
If these ever get out of order, we're going to be breaking our guarantees about structure!

## Make Your Own Trees

It can be really difficult to get all this in your head.
When I was learning this, it *really* helped to visualize it.
So, here's a program that you can use to do the same!

Enter any values in the box below (everything's a string here, so `a` through `z` may work better than numbers if you want to try quite a few values.)
Purple circles indicate empty sets, and the "height balance" of a tree is the height of the right subtree minus the height of the left.

### Things to try:

- Enter 1, 2, and 3 as the values.
  Rotate the tree and see how that works.
- Enter 2, 3, 1 in order.
  Hey, the insert code does what we said it would!
- Enter a through z.
  Trace the operations you'd take to get to any given letter.

{{< elmEmbed src="/scripts/sets/naiveInsertRotate.js" name="NaiveInsertRotate" >}}

Next time we'll apply these rotations automatically when we insert.
See you then!

{{< setsSeriesSignup >}}
